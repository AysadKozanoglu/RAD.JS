# Features

В основе Rad.js лежит многим знакомый [Backbone.js](http://backbonejs.org/).

Более того если ранее вы писали приложения на Backbone то код написан с использованием Rad.js вам покажется знакомым. Основной целью при разработке была необходимость максимально сохранить существующее Backbone API и при этом не нагромождать его новыми понятиями и методами. Поэтому Rad.js проходит все тесты **Backbone**.
  
Но тогда возникает вопрос, а чем же  Rad.js может мне помочь? Что в нем есть чего нет в самом Backbone или в других фреймворках на его основе.

## Работа с DOM   

Если коротко -  Rad.js предлагает иной подход в работе с DOM. Вернее основная идея – это желание избавиться от необходимость работать с DOM и тем самым сконцентрироваться на работе с данными. Для этого мы используем новый [шаблонизатор](https://github.com/Rapid-Application-Development-JS/itemplate) на базе [incremental-dom](https://medium.com/google-developers/introducing-incremental-dom-e98f79ce2c5f#.5mlc5ju6h), который позволяет рендерит и обновлять DOM только в местах где изменились данные. А не перерендеривать шаблон заново. Что позволило увеличить быстродействие [на порядок](https://auth0.com/blog/2016/01/11/updated-and-improved-more-benchmarks-virtual-dom-vs-angular-12-vs-mithril-js-vs-the-rest/).   

Это значительно упрощает работу с View. Достаточно описать как должен выглядит ваш шаблон в зависимости от в входных данных и дальше RAD.js позаботиться о том как нужно обновить DOM.  

Со стороны процесс обновления View становится похожим на обновления компонентов в React.js: меняются данные → вызывается рендер шаблона → обновляется DOM только в тех местах где данные изменились.   

Но в отличии от React.js или VirtualDOM в Rad.js нет промежуточного виртуального дерева и нет дополнительных затрат на процесс сравнения виртуального и реального DOM.  

При этом вы как и раньше можете использовать существующие инструменты Backbone.js: [Backbone.Model](http://backbonejs.org/#Model), [Backbone.Collection](http://backbonejs.org/#Collection), [Backbone.Router](http://backbonejs.org/#Router).

## Nested View

Говоря честно, нам очень нравиться когда с `view` можно работать как с web-component'ом, то есть инжектить его в templates, тем самым инкапсулировать функциональность. И именно этого очень часто не хватает. Поэтому мы постарались реализовать дополнительные механизмы Dependency Injection в нашем фреймверке.